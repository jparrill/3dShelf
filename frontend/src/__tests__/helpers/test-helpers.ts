import { Page, expect } from '@playwright/test'
import path from 'path'
import fs from 'fs'

/**
 * Test utility functions for 3D Organizer E2E tests
 */

export interface TestFile {
  filename: string
  content: string
  type: 'stl' | 'gcode' | 'cad' | 'readme' | 'other'
}

export interface ProjectConfig {
  name: string
  description?: string
  initialFiles?: TestFile[]
}

export interface ConflictResolution {
  filename: string
  resolution: 'skip' | 'overwrite' | 'rename'
}

export class TestFileManager {
  private testDir: string

  constructor(testSuiteName: string) {
    this.testDir = path.join(__dirname, '..', 'fixtures', testSuiteName)
  }

  /**
   * Create a test file and return its path
   */
  createFile(testFile: TestFile): string {
    if (!fs.existsSync(this.testDir)) {
      fs.mkdirSync(this.testDir, { recursive: true })
    }

    const filePath = path.join(this.testDir, testFile.filename)
    fs.writeFileSync(filePath, testFile.content)
    return filePath
  }

  /**
   * Create multiple test files and return their paths
   */
  createFiles(testFiles: TestFile[]): string[] {
    return testFiles.map(file => this.createFile(file))
  }

  /**
   * Clean up all test files
   */
  cleanup(): void {
    if (fs.existsSync(this.testDir)) {
      fs.rmSync(this.testDir, { recursive: true, force: true })
    }
  }

  /**
   * Get predefined test files for common scenarios
   */
  static getCommonTestFiles() {
    return {
      stlFile: {
        filename: 'test-model.stl',
        content: 'solid testmodel\n  facet normal 0.0 0.0 1.0\n    outer loop\n      vertex 0.0 0.0 0.0\n      vertex 1.0 0.0 0.0\n      vertex 0.0 1.0 0.0\n    endloop\n  endfacet\nendsolid',
        type: 'stl' as const
      },
      gcodeFile: {
        filename: 'test-print.gcode',
        content: '; Generated by Test\nG28 ; Home all axes\nG1 X10 Y10 Z0.3 F3000\nG1 X20 Y20 E5 F1500\nM104 S0 ; Turn off hotend\nG28 X0 ; Home X axis',
        type: 'gcode' as const
      },
      readmeFile: {
        filename: 'README.md',
        content: '# Test Project\n\nThis is a test project for the 3D Organizer application.\n\n## Features\n- STL models\n- G-Code files\n- Documentation',
        type: 'readme' as const
      },
      cadFile: {
        filename: 'design.step',
        content: 'ISO-10303-21;\nHEADER;\nFILE_DESCRIPTION((\'\'), \'2;1\');\nFILE_NAME(\'test.step\', \'2024-01-01T00:00:00\', (\'Test\'), (\'Test Org\'), \'Test\', \'Test\', \'\');\nFILE_SCHEMA((\'CONFIG_CONTROL_DESIGN\'));\nENDSEC;\nDATA;\nENDSEC;\nEND-ISO-10303-21;',
        type: 'cad' as const
      },
      largeFile: {
        filename: 'large-model.stl',
        content: 'solid largemodel\n' + 'facet normal 0.0 0.0 1.0\n'.repeat(1000) + 'endsolid',
        type: 'stl' as const
      }
    }
  }
}

export class ProjectTestHelpers {
  /**
   * Create a project with optional initial files
   */
  static async createProject(page: Page, config: ProjectConfig): Promise<string> {
    await page.goto('/')

    // Click Create Project button
    await page.getByRole('button', { name: /create project/i }).click()

    const modal = page.getByTestId('create-project-modal')
    await expect(modal).toBeVisible()

    // Fill project details
    await page.getByPlaceholder(/project name/i).fill(config.name)

    if (config.description) {
      await page.getByPlaceholder(/project description/i).fill(config.description)
    }

    // Upload initial files if provided
    if (config.initialFiles && config.initialFiles.length > 0) {
      const fileManager = new TestFileManager('project-creation')
      const filePaths = fileManager.createFiles(config.initialFiles)

      const fileInput = page.locator('input[type="file"]')
      await fileInput.setInputFiles(filePaths)

      // Verify files are listed
      for (const file of config.initialFiles) {
        await expect(page.getByText(file.filename)).toBeVisible()
      }
    }

    // Submit project creation
    const responsePromise = page.waitForResponse(response =>
      response.url().includes('/api/projects') &&
      response.request().method() === 'POST' &&
      response.status() === 200
    )

    await page.getByRole('button', { name: /create project/i }).nth(1).click()

    const response = await responsePromise
    const responseData = await response.json()

    // Wait for modal to close
    await expect(modal).not.toBeVisible()

    // Verify success notification
    await expect(page.getByText(/project created successfully/i)).toBeVisible()

    return responseData.id.toString()
  }

  /**
   * Navigate to a project's detail page
   */
  static async navigateToProject(page: Page, projectName: string): Promise<void> {
    await page.goto('/')

    const projectCard = page.locator('[data-testid*="project-card"]').filter({ hasText: projectName })
    await expect(projectCard).toBeVisible()
    await projectCard.click()

    // Verify we're on the project detail page
    await expect(page.getByText(projectName)).toBeVisible()
  }

  /**
   * Upload files to an existing project with optional conflict resolutions
   */
  static async uploadFilesToProject(
    page: Page,
    files: TestFile[],
    conflictResolutions?: ConflictResolution[]
  ): Promise<void> {
    const fileManager = new TestFileManager('file-uploads')
    const filePaths = fileManager.createFiles(files)

    // Open upload modal
    await page.getByRole('button', { name: /upload files/i }).click()

    const uploadModal = page.getByTestId('file-upload-modal')
    await expect(uploadModal).toBeVisible()

    // Upload files
    const fileInput = uploadModal.locator('input[type="file"]')
    await fileInput.setInputFiles(filePaths)

    // Verify files are listed
    for (const file of files) {
      await expect(uploadModal.getByText(file.filename)).toBeVisible()
    }

    // Check for conflicts
    await page.getByRole('button', { name: /check conflicts/i }).click()

    await page.waitForResponse(response =>
      response.url().includes('/files/check-conflicts') &&
      response.request().method() === 'POST'
    )

    // Handle conflict resolutions if provided
    if (conflictResolutions && conflictResolutions.length > 0) {
      await expect(page.getByText(/conflicts detected/i)).toBeVisible()

      for (const resolution of conflictResolutions) {
        const conflictSection = page.locator(`[data-testid*="conflict-${resolution.filename}"]`)
        await conflictSection.getByRole('radio', { name: new RegExp(resolution.resolution, 'i') }).check()
      }
    } else {
      // Expect no conflicts
      await expect(page.getByText(/no conflicts detected/i)).toBeVisible()
    }

    // Submit upload
    const uploadPromise = page.waitForResponse(response =>
      response.url().includes('/files') &&
      response.request().method() === 'POST'
    )

    await page.getByRole('button', { name: /upload files/i }).nth(1).click()

    const uploadResponse = await uploadPromise
    expect(uploadResponse.status()).toBe(200)

    // Verify modal closes
    await expect(uploadModal).not.toBeVisible()

    // Verify success message
    await expect(page.getByText(/uploaded successfully|skipped|overwritten/i)).toBeVisible()
  }

  /**
   * Verify project file count
   */
  static async verifyProjectFileCount(page: Page, expectedCount: number): Promise<void> {
    if (expectedCount === 0) {
      await expect(page.getByText(/no files found/i)).toBeVisible()
    } else {
      await expect(page.getByText(`${expectedCount} file${expectedCount > 1 ? 's' : ''}`)).toBeVisible()
    }
  }

  /**
   * Verify specific files exist in project
   */
  static async verifyFilesExist(page: Page, filenames: string[]): Promise<void> {
    for (const filename of filenames) {
      await expect(page.getByText(filename)).toBeVisible()
    }
  }

  /**
   * Verify files do not exist in project
   */
  static async verifyFilesNotExist(page: Page, filenames: string[]): Promise<void> {
    for (const filename of filenames) {
      await expect(page.getByText(filename)).not.toBeVisible()
    }
  }
}

export class APITestHelpers {
  /**
   * Wait for a specific API response
   */
  static async waitForAPIResponse(
    page: Page,
    endpoint: string,
    method: 'GET' | 'POST' | 'PUT' | 'DELETE' = 'GET',
    expectedStatus: number = 200
  ) {
    return page.waitForResponse(response =>
      response.url().includes(endpoint) &&
      response.request().method() === method &&
      response.status() === expectedStatus
    )
  }

  /**
   * Get the response data from a completed response
   */
  static async getResponseData(response: any): Promise<any> {
    try {
      return await response.json()
    } catch (error) {
      console.warn('Failed to parse response as JSON:', error)
      return await response.text()
    }
  }
}

export class ValidationHelpers {
  /**
   * Validate that required form fields show appropriate errors
   */
  static async validateRequiredField(
    page: Page,
    fieldPlaceholder: string,
    submitButtonText: string,
    expectedErrorText: string
  ): Promise<void> {
    // Try to submit without filling the field
    await page.getByRole('button', { name: new RegExp(submitButtonText, 'i') }).click()
    await expect(page.getByText(new RegExp(expectedErrorText, 'i'))).toBeVisible()

    // Try with only spaces
    await page.getByPlaceholder(new RegExp(fieldPlaceholder, 'i')).fill('   ')
    await page.getByRole('button', { name: new RegExp(submitButtonText, 'i') }).click()
    await expect(page.getByText(new RegExp(expectedErrorText, 'i'))).toBeVisible()
  }

  /**
   * Validate accessibility features
   */
  static async validateAccessibility(page: Page): Promise<void> {
    // Check for proper ARIA labels
    const buttons = await page.locator('button').all()
    for (const button of buttons) {
      const ariaLabel = await button.getAttribute('aria-label')
      const text = await button.textContent()
      expect(ariaLabel || text).toBeTruthy()
    }

    // Check for keyboard navigation
    await page.keyboard.press('Tab')
    const focusedElement = await page.evaluate(() => document.activeElement?.tagName)
    expect(focusedElement).toBeTruthy()
  }
}

export const TestConstants = {
  TIMEOUT: {
    SHORT: 5000,
    MEDIUM: 15000,
    LONG: 30000
  },
  FILE_SIZES: {
    SMALL: 1024, // 1KB
    MEDIUM: 1024 * 100, // 100KB
    LARGE: 1024 * 1024, // 1MB
  }
}

export default {
  TestFileManager,
  ProjectTestHelpers,
  APITestHelpers,
  ValidationHelpers,
  TestConstants
}